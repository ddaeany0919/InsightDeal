"""
üî® AuctionScraper - Ïò•ÏÖò Ï†ÑÏö© Ïä§ÌÅ¨ÎûòÌçº

Ïò•ÏÖò(auction.co.kr) Í∞ÄÍ≤© Ï∂îÏ†Å Î∞è ÏÉÅÌíà Ï†ïÎ≥¥ ÏàòÏßë
- eBay Korea Í≥ÑÏó¥ ÏáºÌïëÎ™∞ (GÎßàÏºìÍ≥º ÎèôÏùº Ï≤¥Í≥Ñ)
- Ïò•ÏÖò ÌäπÌôî: Í≤ΩÎß§/Ï¶àÏ¶âÍµ¨Îß§/Í≥†Í∞ùÎßåÏ°±ÏÉµ Îì±
- Í∞ÄÍ≤©ÎπÑÍµêÏÇ¨Ïù¥Ìä∏Ïùò 4Î≤àÏß∏ ÌîåÎû´ÌèºÏúºÎ°ú ÎßàÏßÄÎßâ ÏôÑÏÑ±
- ÏÇ¨Ïö©Ïûê Ï§ëÏã¨: Ï†ÑÏ≤¥ 4Î™∞ Ï§ë ÏµúÏ†ÄÍ∞Ä Ï∞æÍ∏∞ ÏôÑÏÑ±
"""

import re
import json
import asyncio
from typing import List, Optional, Dict
from datetime import datetime
from bs4 import BeautifulSoup
from urllib.parse import urlencode, urlparse

from .base_scraper import BaseScraper, ProductInfo

class AuctionScraper(BaseScraper):
    """üî® Ïò•ÏÖò Ï†ÑÏö© Ïä§ÌÅ¨ÎûòÌçº"""
    
    def __init__(self):
        super().__init__("auction")
        self.base_url = "https://www.auction.co.kr"
        self.search_url = "https://browse.auction.co.kr/search"
        
    def _extract_product_id(self, url: str) -> Optional[str]:
        """üîç Ïò•ÏÖò URLÏóêÏÑú ÏÉÅÌíà ID Ï∂îÏ∂ú"""
        # Ïòà: http://itempage3.auction.co.kr/DetailView.aspx?itemno=A123456789
        patterns = [
            r'itemno=([A-Z]?\d+)',
            r'ItemNo=([A-Z]?\d+)',
            r'/item/([A-Z]?\d+)',
            r'DetailView\.aspx\?.*?([A-Z]\d{8,})'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None
    
    def _parse_auction_price(self, soup: BeautifulSoup) -> Dict[str, int]:
        """üí∞ Ïò•ÏÖò ÌéòÏù¥ÏßÄÏóêÏÑú Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï∂îÏ∂ú"""
        prices = {'current': 0, 'original': 0, 'bid_price': 0}
        
        # Ï¶âÏãúÍµ¨Îß§Í∞Ä (ÏùºÎ∞ò ÌåêÎß§Í∞Ä)
        current_selectors = [
            '.sale_price .price',
            '.item_price .now_price',
            '.price_area .sale_price strong',
            '.buynow_price',
            '.now_price strong'
        ]
        
        for selector in current_selectors:
            element = soup.select_one(selector)
            if element:
                price = self._clean_price(element.get_text(strip=True))
                if price > 0:
                    prices['current'] = price
                    break
        
        # ÏõêÍ∞Ä (Ï†ïÍ∞Ä)
        original_selectors = [
            '.original_price',
            '.item_price .org_price', 
            '.price_area .original_price'
        ]
        
        for selector in original_selectors:
            element = soup.select_one(selector)
            if element:
                price = self._clean_price(element.get_text(strip=True))
                if price > prices['current']:  # ÏõêÍ∞ÄÎäî ÌòÑÏû¨Í∞ÄÎ≥¥Îã§ ÎÜíÏïÑÏïº Ìï®
                    prices['original'] = price
                    break
        
        # Í≤ΩÎß§Í∞Ä (Ïò•ÏÖò ÌäπÌôî)
        bid_selectors = [
            '.bid_price .price',
            '.current_bid_price',
            '.auction_price'
        ]
        
        for selector in bid_selectors:
            element = soup.select_one(selector)
            if element:
                bid_price = self._clean_price(element.get_text(strip=True))
                if bid_price > 0:
                    prices['bid_price'] = bid_price
                    # Í≤ΩÎß§Í∞ÄÍ∞Ä ÏûàÏúºÎ©¥ Îçî Ï†ÄÎ†¥Ìïú Í∞ÄÍ≤© ÏÑ†ÌÉù
                    if prices['current'] == 0 or bid_price < prices['current']:
                        prices['current'] = bid_price
                    break
        
        # ÏõêÍ∞ÄÍ∞Ä ÏóÜÏúºÎ©¥ ÌòÑÏû¨Í∞ÄÎ°ú ÏÑ§Ï†ï
        if prices['original'] == 0:
            prices['original'] = prices['current']
            
        return prices
    
    def _detect_auction_shipping(self, soup: BeautifulSoup) -> Dict[str, any]:
        """üöö Ïò•ÏÖò Î∞∞ÏÜ° Ï†ïÎ≥¥ (Ï¶òÏßôÍµ¨Îß§, Î¨¥Î£åÎ∞∞ÏÜ° Îì±)"""
        info = {
            'shipping_fee': 2500,  # Í∏∞Î≥∏ Î∞∞ÏÜ°ÎπÑ
            'is_free_shipping': False,
            'is_quick_delivery': False,
            'is_satisfaction_shop': False,
            'delivery_type': 'ÏùºÎ∞òÎ∞∞ÏÜ°'
        }
        
        # Ï¶òÏßôÍµ¨Îß§ ÌôïÏù∏
        quick_selectors = [
            '[alt*="Ï¶òÏßôÍµ¨Îß§"]',
            '.quick_delivery',
            ':contains("Ï¶òÏßôÍµ¨Îß§")',
            ':contains("Ï¶òÏßôÎ∞∞ÏÜ°")'
        ]
        
        for selector in quick_selectors:
            if soup.select(selector):
                info['is_quick_delivery'] = True
                info['delivery_type'] = 'Ï¶òÏßôÍµ¨Îß§'
                # Ï¶òÏßôÍµ¨Îß§Îäî Î≥¥ÌÜµ Î¨¥Î£åÎ∞∞ÏÜ°
                info['shipping_fee'] = 0
                info['is_free_shipping'] = True
                break
        
        # Î¨¥Î£åÎ∞∞ÏÜ° ÌôïÏù∏ (Ï¶òÏßôÍµ¨Îß§Í∞Ä ÏïÑÎãå Í≤ΩÏö∞)
        if not info['is_quick_delivery']:
            free_shipping_selectors = [
                '[alt*="Î¨¥Î£åÎ∞∞ÏÜ°"]',
                '.free_delivery',
                ':contains("Î¨¥Î£åÎ∞∞ÏÜ°")',
                ':contains("Î¨¥Î£å")',
                '.delivery_free'
            ]
            
            for selector in free_shipping_selectors:
                if soup.select(selector):
                    info['shipping_fee'] = 0
                    info['is_free_shipping'] = True
                    info['delivery_type'] = 'Î¨¥Î£ºÎ∞∞ÏÜ®'
                    break
        
        # Í≥†Í∞ùÎßåÏ°±ÏÉµ ÌôïÏù∏
        satisfaction_selectors = [
            '[alt*="Í≥†Í∞ùÎßåÏ°±"]',
            '.satisfaction_shop',
            ':contains("Í≥†Í∞ùÎßåÏ°±ÏÉµ")'
        ]
        
        for selector in satisfaction_selectors:
            if soup.select(selector):
                info['is_satisfaction_shop'] = True
                break
                
        return info
    
    async def search_product(self, product_name: str, limit: int = 10) -> List[ProductInfo]:
        """üîç Ïò•ÏÖòÏóêÏÑú ÏÉÅÌíà Í≤ÄÏÉâ"""
        try:
            params = {
                'keyword': product_name,
                'itemno': '',
                'nickname': '',
                'frm': 'hometab',
                'dom': '1',
                'isSuggestion': 'No',
                'OrderingType': '2'  # Ïù∏Í∏∞Ïàú
            }
            
            url = f"{self.search_url}?{urlencode(params)}"
            html = await self._make_request(url)
            
            if not html:
                return []
            
            soup = BeautifulSoup(html, 'html.parser')
            products = []
            
            # ÏÉÅÌíà Î™©Î°ù ÌååÏã±
            product_items = soup.select('.component--item_card, .item-wrap')[:limit]
            
            for item in product_items:
                try:
                    # ÏÉÅÌíàÎ™Ö
                    title_elem = item.select_one('.text--title, .item_title a')
                    if not title_elem:
                        continue
                    title = self._clean_product_name(title_elem.get_text(strip=True))
                    
                    # ÏÉÅÌíà URL
                    link_elem = item.select_one('a') or title_elem
                    if not link_elem:
                        continue
                    href = link_elem.get('href', '')
                    if href.startswith('/'):
                        product_url = self.base_url + href
                    elif href.startswith('http'):
                        product_url = href
                    else:
                        continue
                    
                    # Í∞ÄÍ≤© Ï†ïÎ≥¥
                    prices = self._parse_auction_price(item)
                    if prices['current'] == 0:
                        continue
                    
                    # Ìï†Ïù∏Ïú® Í≥ÑÏÇ∞
                    discount_rate = 0
                    if prices['original'] > prices['current']:
                        discount_rate = int((prices['original'] - prices['current']) / prices['original'] * 100)
                    
                    # Ïù¥ÎØ∏ÏßÄ
                    img_elem = item.select_one('img')
                    image_url = img_elem.get('src', '') if img_elem else ''
                    if image_url.startswith('//'):
                        image_url = 'https:' + image_url
                    
                    # Î∞∞ÏÜ° Ï†ïÎ≥¥
                    shipping_info = self._detect_auction_shipping(item)
                    
                    # ÌèâÏ†ê
                    rating = 0.0
                    rating_elem = item.select_one('.rating, .grade')
                    if rating_elem:
                        try:
                            rating_text = rating_elem.get_text(strip=True)
                            rating_match = re.findall(r'[\d.]+', rating_text)
                            if rating_match:
                                rating = float(rating_match[0])
                        except:
                            pass
                    
                    # Î¶¨Î∑∞ Ïàò
                    review_count = 0
                    review_elem = item.select_one('.review_count')
                    if review_elem:
                        review_count = self._clean_price(review_elem.get_text(strip=True))
                    
                    # ÌåêÎß§Ïûê Íµ¨Î∂Ñ
                    seller_name = "Ïò•ÏÖò"
                    if shipping_info['is_satisfaction_shop']:
                        seller_name = "Í≥†Í∞ùÎßåÏ°±ÏÉµ"
                    elif shipping_info['is_quick_delivery']:
                        seller_name = "Ï¶òÏßôÍµ¨Îß§"
                    
                    product = ProductInfo(
                        platform="auction",
                        product_name=title,
                        current_price=prices['current'],
                        original_price=prices['original'],
                        discount_rate=discount_rate,
                        product_url=product_url,
                        image_url=image_url,
                        shipping_fee=shipping_info['shipping_fee'],
                        rating=rating,
                        review_count=review_count,
                        seller_name=seller_name,
                        is_available=True,
                        updated_at=datetime.now()
                    )
                    
                    products.append(product)
                    
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è Ïò•ÏÖò ÏÉÅÌíà ÌååÏã± Ïò§Î•ò: {e}")
                    continue
            
            self.logger.info(f"‚úÖ Ïò•ÏÖò Í≤ÄÏÉâ ÏôÑÎ£å: {len(products)}Í∞ú ÏÉÅÌíà")
            return products
            
        except Exception as e:
            self.logger.error(f"‚ùå Ïò•ÏÖò Í≤ÄÏÉâ Ïã§Ìå®: {e}")
            return []
    
    async def get_product_detail(self, product_url: str) -> Optional[ProductInfo]:
        """üìã Ïò•ÏÖò ÏÉÅÌíà ÏÉÅÏÑ∏ Ï†ïÎ≥¥"""
        try:
            if not self.is_valid_url(product_url):
                self.logger.warning(f"‚ö†Ô∏è ÏûòÎ™ªÎêú Ïò•ÏÖò URL: {product_url}")
                return None
                
            html = await self._make_request(product_url)
            if not html:
                return None
                
            soup = BeautifulSoup(html, 'html.parser')
            
            # ÏÉÅÌíàÎ™Ö
            title_selectors = [
                '.itemtitle',
                '.item_title h1',
                '.product_name',
                'h1.title'
            ]
            
            title = ""
            for selector in title_selectors:
                elem = soup.select_one(selector)
                if elem:
                    title = self._clean_product_name(elem.get_text(strip=True))
                    break
                    
            if not title:
                self.logger.warning("‚ö†Ô∏è Ïò•ÏÖò ÏÉÅÌíàÎ™Ö Ï∂îÏ∂ú Ïã§Ìå®")
                return None
            
            # Í∞ÄÍ≤© Ï†ïÎ≥¥
            prices = self._parse_auction_price(soup)
            if prices['current'] == 0:
                self.logger.warning("‚ö†Ô∏è Ïò•ÏÖò Í∞ÄÍ≤© Ï∂îÏ∂ú Ïã§Ìå®")
                return None
            
            # Ìï†Ïù∏Ïú®
            discount_rate = 0
            if prices['original'] > prices['current']:
                discount_rate = int((prices['original'] - prices['current']) / prices['original'] * 100)
            
            # Î∞∞ÏÜ° Ï†ïÎ≥¥
            shipping_info = self._detect_auction_shipping(soup)
            
            # Ïù¥ÎØ∏ÏßÄ
            img_elem = soup.select_one('.thumb img, .item_photo img')
            image_url = img_elem.get('src', '') if img_elem else ''
            if image_url.startswith('//'):
                image_url = 'https:' + image_url
            
            # ÌèâÏ†ê
            rating = 0.0
            rating_elem = soup.select_one('.score, .rating_score')
            if rating_elem:
                try:
                    rating = float(rating_elem.get_text(strip=True).replace('Ï†ê', ''))
                except:
                    pass
            
            # Î¶¨Î∑∞ Ïàò
            review_count = 0
            review_elem = soup.select_one('.review_count, .score .count')
            if review_elem:
                review_count = self._clean_price(review_elem.get_text(strip=True))
            
            # ÌåêÎß§Ïûê
            seller_name = "Ïò•ÏÖò"
            if shipping_info['is_satisfaction_shop']:
                seller_name = "Í≥†Í∞ùÎßåÏ°±ÏÉµ"
            elif shipping_info['is_quick_delivery']:
                seller_name = "Ï¶òÏßôÍµ¨Îß§"
            else:
                seller_elem = soup.select_one('.seller_info .name, .shop_name')
                if seller_elem:
                    seller_name = seller_elem.get_text(strip=True)
            
            product = ProductInfo(
                platform="auction",
                product_name=title,
                current_price=prices['current'],
                original_price=prices['original'],
                discount_rate=discount_rate,
                product_url=product_url,
                image_url=image_url,
                shipping_fee=shipping_info['shipping_fee'],
                rating=rating,
                review_count=review_count,
                seller_name=seller_name,
                is_available=True,
                updated_at=datetime.now()
            )
            
            self.logger.info(f"‚úÖ Ïò•ÏÖò ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå: {title} - {prices['current']:,}Ïõê")
            return product
            
        except Exception as e:
            self.logger.error(f"‚ùå Ïò•ÏÖò ÏÉÅÌíà ÏÉÅÏÑ∏ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return None